{
  "version": 3,
  "sources": ["../../../src/challenge/index.js", "../../../src/utils/index.js"],
  "sourcesContent": ["import { CognitoIdentityProviderClient, RespondToAuthChallengeCommand } from \"@aws-sdk/client-cognito-identity-provider\";\r\nimport { generateCognitoSecretHash } from  '../utils/index.js';\r\n\r\nconst client = new CognitoIdentityProviderClient({ region: \"us-east-1\" });\r\n\r\nexport const challengeHandler = async (event) => {\r\n  try {\r\n    const credentials = JSON.parse(event.body);\r\n    const params = {\r\n      ChallengeName: \"NEW_PASSWORD_REQUIRED\",\r\n      ClientId: process.env.COGNITO_ID,\r\n      ChallengeResponses: {\r\n        USERNAME: credentials.USER_ID_FOR_SRP,\r\n        NEW_PASSWORD: credentials.newPassword,\r\n        SECRET_HASH: generateCognitoSecretHash(\r\n          process.env.COGNITO_ID ,\r\n          process.env.COGNITO_SECRET,\r\n          credentials.USER_ID_FOR_SRP,\r\n        ),\r\n      },\r\n      Session: credentials.Session,\r\n    }\r\n    const command = new RespondToAuthChallengeCommand(params);\r\n    const responseBody = await client.send(command);\r\n    \r\n    return { \r\n        statusCode: 200, \r\n        body: JSON.stringify(responseBody)\r\n    };\r\n  }catch(err){  \r\n    const responseBody = { message: `Error: ${err.message}` }\r\n    return {\r\n        statusCode: 500,\r\n        body: JSON.stringify(responseBody)\r\n    };\r\n  } \r\n}", "import { createHmac } from 'crypto';\r\n\r\nexport function generateCognitoSecretHash(clientId, clientSecret, username,) {\r\n    const message = username + clientId;\r\n    return createHmac('sha256', clientSecret).update(message).digest('base64');\r\n}\r\n\r\nexport function generateUniqueIdentify(input) {\r\n    const lowerCaseString = input.toLowerCase();\r\n    let string = lowerCaseString.replace(/\\s+/g, '');\r\n    const uuidv4 = crypto.randomUUID();\r\n    string += '-' + uuidv4.split('-')[4]\r\n    return string;\r\n}\r\n\r\nexport function validateStorePayload(payload) {\r\n    const requiredFields = ['storeName', 'email'];\r\n\r\n    requiredFields.forEach(field => {\r\n        if (!(field in payload)) {\r\n            throw new Error(`Mandatory field '${field}' missing.`)\r\n        }\r\n    }); \r\n    if (typeof payload.storeName !== 'string') {\r\n        throw new Error(`Field 'storeName' must be a string.`)\r\n    }\r\n    if (typeof payload.email !== 'string') {\r\n        throw new Error(`Field 'email' must be a string.`)\r\n    }\r\n}\r\n\r\nexport function validateProductPayload(payload) {\r\n    const requiredFields = ['storeId', 'productName', 'price'];\r\n\r\n    requiredFields.forEach(field => {\r\n        if (!(field in payload)) {\r\n            throw new Error(`Mandatory field '${field}' missing.`)\r\n        }\r\n    }); \r\n    if (typeof payload.storeId !== 'string') {\r\n        throw new Error(`Field 'storeId' must be a string.`)\r\n    }\r\n    if (typeof payload.productName !== 'string') {\r\n        throw new Error(`Field 'productName' must be a string.`)\r\n    }\r\n    if (typeof payload.price !== 'number') {\r\n        throw new Error(`Field 'price' must be a number.`)\r\n    }\r\n}"],
  "mappings": "4ZAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,sBAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAA6E,qDCA7E,IAAAC,EAA2B,kBAEpB,SAASC,EAA0BC,EAAUC,EAAcC,EAAW,CACzE,IAAMC,EAAUD,EAAWF,EAC3B,SAAO,cAAW,SAAUC,CAAY,EAAE,OAAOE,CAAO,EAAE,OAAO,QAAQ,CAC7E,CDFA,IAAMC,EAAS,IAAI,gCAA8B,CAAE,OAAQ,WAAY,CAAC,EAE3DC,EAAmB,MAAOC,GAAU,CAC/C,GAAI,CACF,IAAMC,EAAc,KAAK,MAAMD,EAAM,IAAI,EACnCE,EAAS,CACb,cAAe,wBACf,SAAU,QAAQ,IAAI,WACtB,mBAAoB,CAClB,SAAUD,EAAY,gBACtB,aAAcA,EAAY,YAC1B,YAAaE,EACX,QAAQ,IAAI,WACZ,QAAQ,IAAI,eACZF,EAAY,eACd,CACF,EACA,QAASA,EAAY,OACvB,EACMG,EAAU,IAAI,gCAA8BF,CAAM,EAClDG,EAAe,MAAMP,EAAO,KAAKM,CAAO,EAE9C,MAAO,CACH,WAAY,IACZ,KAAM,KAAK,UAAUC,CAAY,CACrC,CACF,OAAOC,EAAI,CACT,IAAMD,EAAe,CAAE,QAAS,UAAUC,EAAI,OAAO,EAAG,EACxD,MAAO,CACH,WAAY,IACZ,KAAM,KAAK,UAAUD,CAAY,CACrC,CACF,CACF",
  "names": ["challenge_exports", "__export", "challengeHandler", "__toCommonJS", "import_client_cognito_identity_provider", "import_crypto", "generateCognitoSecretHash", "clientId", "clientSecret", "username", "message", "client", "challengeHandler", "event", "credentials", "params", "generateCognitoSecretHash", "command", "responseBody", "err"]
}
